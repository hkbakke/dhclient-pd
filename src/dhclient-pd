#!/usr/bin/env python3

import argparse
import fnmatch
import hashlib
import json
import logging
import os
import subprocess
from functools import cached_property
from ipaddress import IPv6Address, IPv6Network, IPv6Interface
from typing import Iterator, Optional


LOOPBACK_INTERFACE = "lo"


LOGGER = logging.getLogger(__name__)


class Interface:
    def __init__(
        self,
        name: str,
        configure: bool = False,
        loopback: bool = False,
        identifiers: Optional[list[str]] = None,
    ):
        self.name = name
        self.configure = configure
        self.loopback = loopback

        if identifiers is None:
            self.identifiers = ["::1"]
        else:
            self.identifiers = identifiers

    @cached_property
    def _addrs(self) -> list[IPv6Interface]:
        addrs = []

        p = subprocess.run(
            ["ip", "-6", "-j", "addr", "show", self.name, "scope", "global"],
            check=True,
            capture_output=True,
        )

        for interface in json.loads(p.stdout):
            for addr in interface["addr_info"]:
                if addr.get("family") == "inet6":
                    addrs.append(IPv6Interface(f'{addr["local"]}/{addr["prefixlen"]}'))

        return addrs

    @property
    def addrs(self) -> list[IPv6Interface]:
        return self._addrs

    def add_addr(self, addr: IPv6Interface) -> None:
        if addr in self.addrs:
            LOGGER.info("Address %s is already added to %s", addr, self.name)
            return

        LOGGER.info("Adding address %s to %s", addr, self.name)
        subprocess.run(
            ["ip", "-6", "addr", "add", addr.with_prefixlen, "dev", self.name],
            check=True,
        )

        # Clear cache for _addrs to force a new lookup if needed
        if hasattr(self, "_addrs"):
            del self._addrs

    def remove_addr(self, addr: IPv6Interface) -> None:
        LOGGER.info("Removing address %s from %s", addr, self.name)
        subprocess.run(
            ["ip", "-6", "addr", "del", addr.with_prefixlen, "dev", self.name],
            check=True,
        )

        # Clear cache for _addrs to force a new lookup if needed
        if hasattr(self, "_addrs"):
            del self._addrs

    def add_prefix(self, prefix: IPv6Network) -> None:
        if self.loopback:
            prefixlen = 128
        else:
            prefixlen = prefix.prefixlen

        for identifier in self.identifiers:
            addr = prefix.network_address + int(IPv6Address(identifier))
            self.add_addr(IPv6Interface(f"{addr}/{prefixlen}"))

    def remove_prefix(self, prefix: IPv6Network) -> None:
        for addr in self.addrs:
            if addr in prefix:
                self.remove_addr(addr)


class Prefix:
    ADDR_PREFIXLEN = 64

    def __init__(self, prefix: str):
        self.prefix = IPv6Network(prefix)
        self._assigned: list[int] = []

    @cached_property
    def _subnets(self) -> list[IPv6Network]:
        return list(self.prefix.subnets(new_prefix=self.ADDR_PREFIXLEN))

    @property
    def subnets(self) -> list[IPv6Network]:
        return self._subnets

    def _get_subnet_prefix(self, interface: str) -> IPv6Network:
        """
        Generate a deterministic interface prefix from the interface name. It
        is done this way to ensure the existing interface prefixes are not
        changed if additional interfaces are added or existing ones removed.
        """
        name_hash = hashlib.sha256(interface.encode("utf-8")).hexdigest()
        subnet_count = len(self.subnets)
        subnet_index = int(name_hash, 16) % subnet_count

        # In the unlikely event that we get a name hash subnet collition,
        # iterate over the available prefixes until an unused prefix is found.
        while subnet_index in self._assigned:
            subnet_index = (subnet_index + 1) % subnet_count

        self._assigned.append(subnet_index)
        return self.subnets[subnet_index]

    def add(self, interfaces: list[Interface]) -> None:
        for interface in interfaces:
            if interface.configure:
                subnet = self._get_subnet_prefix(interface.name)
                interface.add_prefix(subnet)
            else:
                interface.remove_prefix(self.prefix)

    def remove(self, interfaces: list[Interface]) -> None:
        for interface in interfaces:
            interface.remove_prefix(self.prefix)


def interface_match(name: str, patterns: list[str]) -> bool:
    for pattern in patterns:
        if fnmatch.fnmatch(name, pattern):
            return True

    return False


def get_interfaces() -> Iterator[Interface]:
    p = subprocess.run(
        ["ip", "-6", "-j", "addr", "show"],
        check=True,
        capture_output=True,
    )

    for interface in json.loads(p.stdout):
        for addr in interface["addr_info"]:
            if addr["family"] != "inet6":
                continue

            yield Interface(
                interface["ifname"],
            )
            break


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i",
        "--interface",
        metavar="NAME",
        action="append",
        default=[],
        help="interfaces to assign prefix to",
    )
    parser.add_argument(
        "-l",
        "--loopback",
        metavar="IDENTIFIER",
        action="append",
        default=[],
        help="assign loopback address (prefix:identifier/128)",
    )
    parser.add_argument(
        "-x",
        "--exclude-interface",
        metavar="NAME",
        action="append",
        default=[],
        help="interfaces to always ignore",
    )
    parser.add_argument(
        "-p",
        "--prefix",
        metavar="PREFIX",
        nargs="?",
        help="prefix to add",
    )
    parser.add_argument(
        "-o",
        "--old-prefix",
        metavar="PREFIX",
        nargs="?",
        help="prefix to remove",
    )
    args = parser.parse_args()

    LOGGER.setLevel(logging.INFO)
    console = logging.StreamHandler()
    LOGGER.addHandler(console)

    interfaces = list(get_interfaces())

    for interface in interfaces:
        if interface_match(interface.name, args.interface) and not interface_match(
            interface.name, args.exclude_interface
        ):
            interface.configure = True

        if args.loopback and interface.name == LOOPBACK_INTERFACE:
            interface.configure = True
            interface.identifiers = args.loopback
            interface.loopback = True

    if args.prefix:
        LOGGER.info("Delegated prefix: %s", args.prefix)
        prefix = Prefix(args.prefix)
        prefix.add(interfaces)

    if args.old_prefix and args.old_prefix != args.prefix:
        LOGGER.info("Old prefix: %s", args.old_prefix)
        prefix = Prefix(args.old_prefix)
        prefix.remove(interfaces)


if __name__ == "__main__":
    main()
