#!/usr/bin/env python3

import argparse
import fnmatch
import hashlib
import json
import logging
import os
import subprocess
from functools import cached_property
from ipaddress import IPv6Address, IPv6Network, IPv6Interface
from typing import Iterator, Optional


LOOPBACK_INTERFACE = "lo"


LOGGER = logging.getLogger(__name__)


class Interface:
    def __init__(
        self,
        name: str,
        configure: bool = False,
        loopback: bool = False,
        identifiers: Optional[list[str]] = None,
    ):
        self.name = name
        self.configure = configure
        self.loopback = loopback

        if identifiers is None:
            self.identifiers = ["::1"]
        else:
            self.identifiers = identifiers

    @cached_property
    def _addrs(self) -> list[IPv6Interface]:
        addrs = []

        p = subprocess.run(
            ["ip", "-6", "-j", "addr", "show", self.name, "scope", "global"],
            check=True,
            capture_output=True,
        )

        for interface in json.loads(p.stdout):
            for addr in interface["addr_info"]:
                if addr.get("family") == "inet6":
                    addrs.append(IPv6Interface(f'{addr["local"]}/{addr["prefixlen"]}'))

        return addrs

    @property
    def addrs(self) -> list[IPv6Interface]:
        return self._addrs

    def add_addr(self, addr: IPv6Interface) -> None:
        if addr in self.addrs:
            LOGGER.info("Address %s is already added to %s", addr, self.name)
            return

        LOGGER.info("Adding address %s to %s", addr, self.name)
        subprocess.run(
            ["ip", "-6", "addr", "add", addr.with_prefixlen, "dev", self.name],
            check=True,
        )

        # Clear cache for _addrs to force a new lookup if needed
        if hasattr(self, "_addrs"):
            del self._addrs

    def remove_addr(self, addr: IPv6Interface) -> None:
        LOGGER.info("Removing address %s from %s", addr, self.name)
        subprocess.run(
            ["ip", "-6", "addr", "del", addr.with_prefixlen, "dev", self.name],
            check=True,
        )

        # Clear cache for _addrs to force a new lookup if needed
        if hasattr(self, "_addrs"):
            del self._addrs

    def add_prefix(self, prefix: IPv6Network) -> None:
        if self.loopback:
            prefixlen = 128
        else:
            prefixlen = prefix.prefixlen

        for identifier in self.identifiers:
            addr = prefix.network_address + int(IPv6Address(identifier))
            self.add_addr(IPv6Interface(f"{addr}/{prefixlen}"))

    def remove_prefix(self, prefix: IPv6Network) -> None:
        for addr in self.addrs:
            if addr in prefix:
                self.remove_addr(addr)


class Prefix:
    ADDR_PREFIXLEN = 64

    def __init__(self, prefix: str):
        self.prefix = IPv6Network(prefix)

    @cached_property
    def _subnets(self) -> list[IPv6Network]:
        return list(self.prefix.subnets(new_prefix=self.ADDR_PREFIXLEN))

    @property
    def subnets(self) -> list[IPv6Network]:
        return self._subnets

    def _get_subnet_prefix(self, interface: str) -> IPv6Network:
        """
        Generate a deterministic interface prefix from the interface name. It
        is done this way to ensure the existing interface prefixes are not
        changed if additional interfaces are added or existing ones removed.
        """
        md5 = hashlib.md5(interface.encode("utf-8")).hexdigest()
        subnet_index = int(md5, 16) % len(self.subnets)
        return self.subnets[subnet_index]

    def add(self, interfaces: list[Interface]) -> None:
        for interface in interfaces:
            if interface.configure:
                subnet = self._get_subnet_prefix(interface.name)
                interface.add_prefix(subnet)
            else:
                interface.remove_prefix(self.prefix)

    def remove(self, interfaces: list[Interface]) -> None:
        for interface in interfaces:
            interface.remove_prefix(self.prefix)


def interface_match(name: str, patterns: list[str]) -> bool:
    for pattern in patterns:
        if fnmatch.fnmatch(name, pattern):
            return True

    return False


def get_interfaces() -> Iterator[Interface]:
    p = subprocess.run(
        ["ip", "-6", "-j", "addr", "show"],
        check=True,
        capture_output=True,
    )

    for interface in json.loads(p.stdout):
        for addr in interface["addr_info"]:
            if addr["family"] != "inet6":
                continue

            yield Interface(
                interface["ifname"],
            )
            break


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i",
        "--interface",
        metavar="NAME",
        action="append",
        default=[],
        help="interface to assign prefix to",
    )
    parser.add_argument(
        "-l",
        "--loopback",
        metavar="IDENTIFIER",
        action="append",
        default=[],
        help="assign loopback address (prefix:identifier/128)",
    )
    parser.add_argument(
        "-x",
        "--exclude-interface",
        metavar="NAME",
        action="append",
        default=[],
        help="interfaces to always ignore",
    )
    args = parser.parse_args()

    LOGGER.setLevel(logging.INFO)
    console = logging.StreamHandler()
    LOGGER.addHandler(console)

    # These environment variables are populated by dhclient
    reason = os.getenv("reason")
    new_ip6_prefix = os.getenv("new_ip6_prefix")  # prefix from new lease
    old_ip6_prefix = os.getenv("old_ip6_prefix")  # prefix from previous lease

    if reason not in ["BOUND6", "EXPIRE6", "REBIND6", "REBOOT6", "RENEW6"]:
        return

    interfaces = list(get_interfaces())

    for interface in interfaces:
        if interface_match(interface.name, args.interface) and not interface_match(
            interface.name, args.exclude_interface
        ):
            interface.configure = True

        if args.loopback and interface.name == LOOPBACK_INTERFACE:
            interface.configure = True
            interface.identifiers = args.loopback
            interface.loopback = True

    if new_ip6_prefix is not None:
        LOGGER.info("Prefix delegation: %s", new_ip6_prefix)
        prefix = Prefix(new_ip6_prefix)
        prefix.add(interfaces)

    if old_ip6_prefix is not None and old_ip6_prefix != new_ip6_prefix:
        LOGGER.info("Old prefix delegation: %s", old_ip6_prefix)
        prefix = Prefix(old_ip6_prefix)
        prefix.remove(interfaces)


if __name__ == "__main__":
    main()
